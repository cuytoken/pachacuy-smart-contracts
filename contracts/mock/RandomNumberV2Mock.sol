// SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;

import "../vrf/CallbackInterface.sol";

contract RandomNumberV2Mock {
    // Random numbers for bouncing
    uint256 randomNumberOne;
    uint256 randomNumberTwo;
    uint256 constant idReqBounce = 101010101;
    bool ongoinBouncingRN;

    constructor() {
        // Random number for bouncing
        randomNumberOne = _getRadomNumberOne(block.timestamp, msg.sender);
        randomNumberTwo = _getRandomNumberTwo(block.timestamp, msg.sender);
    }

    /**
     * @dev Indicated the data after the Random Number has been generated by VRF
     * @param requestId The request id of the Chainlink VRF
     * @param smartCAddress Smart Contract who is calling the random number function
     * @param walletAddress Wallet address for which the random number is generated
     * @param randomWords Array of random words generated by the VRF
     */
    event RandomNumberFulfilled(
        uint256 requestId,
        address smartCAddress,
        address walletAddress,
        uint256[] randomWords
    );

    event ErrorFromVrfCallback(
        string error,
        uint256 requestId,
        address smartCAddress,
        address walletAddress
    );

    event ErrorNotHandled(
        bytes reason,
        uint256 requestId,
        address smartCAddress,
        address walletAddress
    );

    event RandomNumberDelivered(
        uint256 requestId,
        address smartCAddress,
        address walletAddress,
        uint256[] randomWords
    );

    address _smartc;
    address account;

    /**
     * @dev A mapping from the account to the latest random number obtained for this account
     */
    mapping(address => bool) internal whiteListSmartContract;

    function requestRandomNumber(address _account) external {
        _smartc = msg.sender;
        account = _account;
    }

    /**
     * @dev Consumed by the Client to request a random number
     */
    function requestRandomNumber(address _account, uint32) external {
        _smartc = msg.sender;
        account = _account;
    }

    function verifyIfRequestHasBeenCalled(address _sc)
        external
        view
        returns (bool)
    {
        return _sc == _smartc;
    }

    // Callback function for the VRF request
    function requestRandomNumberBouncing(
        address _account,
        uint32 _amountNumbers
    ) external returns (uint256[] memory) {
        _smartc = msg.sender;
        account = _account;
        // respondes inmediately the random numbers
        uint256[] memory randomWords = new uint256[](_amountNumbers);
        if (_amountNumbers == 1) {
            randomWords[0] = _getRadomNumberOne(randomNumberOne, _account);
        } else {
            randomWords[0] = _getRadomNumberOne(randomNumberOne, _account);
            randomWords[1] = _getRandomNumberTwo(randomNumberTwo, _account);
        }
        // updates with VRF
        if (!ongoinBouncingRN) {
            ongoinBouncingRN = true;
        }
        return randomWords;
    }

    function fulfillRandomWords(uint256 requestId, uint256[] memory randomWords)
        external
    {
        if (ongoinBouncingRN) {
            if (randomWords.length == 1) {
                randomNumberOne = randomWords[0];
            } else if (randomWords.length == 2) {
                randomNumberOne = randomWords[0];
                randomNumberTwo = randomWords[1];
            }
            ongoinBouncingRN = false;
        }
        _fulfillRandomWords(requestId, randomWords);
    }

    function _fulfillRandomWords(
        uint256 requestId,
        uint256[] memory randomWords
    ) internal {
        emit RandomNumberDelivered(requestId, _smartc, account, randomWords);
        try
            CallbackInterface(_smartc).fulfillRandomness(account, randomWords)
        {} catch Error(string memory reason) {
            emit ErrorFromVrfCallback(reason, requestId, _smartc, account);
        } catch (bytes memory reason) {
            emit ErrorNotHandled(reason, requestId, _smartc, account);
        }
    }

    function addToWhiteList(address _smartContractAddress) public {
        whiteListSmartContract[_smartContractAddress] = true;
    }

    function _getRadomNumberOne(uint256 _random, address _account)
        internal
        view
        returns (uint256)
    {
        return
            uint256(
                keccak256(
                    abi.encodePacked(
                        block.timestamp,
                        msg.sender,
                        _random,
                        _account
                    )
                )
            );
    }

    function _getRandomNumberTwo(uint256 _random, address _account)
        internal
        view
        returns (uint256)
    {
        return
            uint256(
                keccak256(
                    abi.encodePacked(
                        block.timestamp,
                        msg.sender,
                        _random,
                        _random,
                        _account
                    )
                )
            );
    }
}
